#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu
from geometry_msgs.msg import TransformStamped
import numpy as np
import math
import tf2_ros

## Moving by RPY

class ImuTfPublisher(Node):
    def __init__(self):
        super().__init__('imu_tf_publisher')

        # 파라미터 설정
        self.declare_parameter('frame_id', 'map')
        self.declare_parameter('child_frame_id', 'base_link')
        self.declare_parameter('use_imu_orientation', True)
        self.declare_parameter('position_drift_correction', 0.999)
        self.declare_parameter('velocity_drift_correction', 0.9)
        
        # 더 강한 필터링 적용
        self.declare_parameter('accel_noise_threshold', 0.03)
        self.declare_parameter('velocity_reset_threshold', 0.005)

        # 파라미터 가져오기
        self.frame_id = self.get_parameter('frame_id').value
        self.child_frame_id = self.get_parameter('child_frame_id').value
        self.use_imu_orientation = self.get_parameter('use_imu_orientation').value
        self.position_drift_correction = self.get_parameter('position_drift_correction').value
        self.velocity_drift_correction = self.get_parameter('velocity_drift_correction').value
        self.accel_noise_threshold = self.get_parameter('accel_noise_threshold').value
        self.velocity_reset_threshold = self.get_parameter('velocity_reset_threshold').value

        # IMU 구독
        self.imu_sub = self.create_subscription(
            Imu, 'imu', self.imu_callback, 10)
        
        # TF 브로드캐스터
        self.tf_broadcaster = tf2_ros.TransformBroadcaster(self)
        
        # 상태 변수
        self.position = np.zeros(3)  # x, y, z
        self.velocity = np.zeros(3)  # vx, vy, vz
        self.orientation = np.array([0.0, 0.0, 0.0, 1.0])  # x, y, z, w
        self.prev_time = None
        self.accel_filter = np.zeros(3)  # 가속도 필터 초기화
        
        self.get_logger().info("IMU TF Publisher initialized")
        
        # 새로운 고정 TF 발행 (world -> map)
        self.fixed_tf_timer = self.create_timer(0.1, self.publish_fixed_tf)
        
    def imu_callback(self, msg):
        current_time = self.get_clock().now()
        
        # 첫 메시지인 경우
        if self.prev_time is None:
            self.prev_time = current_time
            
            # IMU 방향 정보가 있고 사용하기로 설정된 경우
            if self.use_imu_orientation:
                self.orientation = np.array([
                    msg.orientation.x,
                    msg.orientation.y,
                    msg.orientation.z,
                    msg.orientation.w
                ])
            return
        
        # 시간 간격 계산
        dt = (current_time - self.prev_time).nanoseconds / 1e9
        if dt <= 0.0 or dt > 0.5:  # 너무 크거나 작은 dt는 무시
            self.prev_time = current_time
            return
        
        # 쿼터니언 정규화
        if self.use_imu_orientation:
            q_norm = math.sqrt(
                msg.orientation.x**2 + 
                msg.orientation.y**2 + 
                msg.orientation.z**2 + 
                msg.orientation.w**2
            )
            
            if q_norm > 0.01:
                self.orientation = np.array([
                    msg.orientation.x / q_norm,
                    msg.orientation.y / q_norm,
                    msg.orientation.z / q_norm,
                    msg.orientation.w / q_norm
                ])
        
        # 회전 행렬 계산
        R = self.quaternion_to_rotation_matrix(self.orientation)
        
        # 가속도에서 중력 제거 부분 개선
        # 현재 방식은 회전 행렬을 이용해 중력을 제거하고 있지만, 
        # 센서 출력이 이미 중력을 포함하고 있어서 정확한 제거가 안됨
        
        # 더 정밀한 중력 벡터 계산 (MPU6050은 가속도계가 중력을 포함)
        gravity_vector = np.array([0.0, 0.0, 9.81])  # 지구 중력
        rotated_gravity = np.dot(R, gravity_vector)  # 현재 방향에 따른 중력
        
        original_accel = np.array([
            msg.linear_acceleration.x,
            msg.linear_acceleration.y,
            msg.linear_acceleration.z
        ])
        
        # 좌표축 방향 수정 (실제 센서 방향에 맞게 조정 필요)
        # x, y 교체 및 부호 반전 (MPU6050 좌표계 → ROS 좌표계)
        linear_accel = np.array([
            -original_accel[1],  # y를 -x로
            original_accel[0],   # x를 y로
            original_accel[2]    # z 유지
        ])
        
        # 중력 보정 방식 수정
        global_accel = np.dot(R, linear_accel) - rotated_gravity
        
        # 저주파 통과 필터 (가속도 노이즈 제거용)
        alpha = 0.2  # 필터 계수 (0에 가까울수록 더 많은 필터링, 1이면 필터링 없음)
        self.accel_filter = alpha * global_accel + (1 - alpha) * self.accel_filter
        
        # 정지 상태 감지 - 어느 정도의 움직임인지 판단
        is_stationary = np.linalg.norm(self.accel_filter) < 0.08
        
        # 정지 상태에서는 속도를 빠르게 감소
        if is_stationary:
            self.velocity *= 0.8  # 더 강한 감쇠
        else:
            # 움직이는 상태에서는 속도 업데이트
            self.velocity += self.accel_filter * dt
            
            # 축별 서로 다른 감쇠 적용
            self.velocity[0] *= 0.95  # x축 감쇠
            self.velocity[1] *= 0.95  # y축 감쇠
            self.velocity[2] *= 0.97  # z축 감쇠 (다른 축보다 적게)
        
        # 위치 업데이트 전에 속도 제한 (최대 속도 조정)
        max_velocity = 0.3  # m/s
        vel_norm = np.linalg.norm(self.velocity)
        if vel_norm > max_velocity:
            self.velocity *= (max_velocity / vel_norm)
        
        # 위치 업데이트
        pos_change = self.velocity * dt
        self.position += pos_change
        
        # z축이 계속 떨어지는 것 방지 - z축에 별도의 보정 적용
        if abs(self.position[2]) > 0.5:  # z축 위치가 너무 멀어지면 서서히 원점으로
            self.position[2] *= 0.99  # z축 위치 천천히 감소
        
        # 정지 상태이고 속도가 매우 낮으면 위치 드리프트 보정
        if is_stationary and np.linalg.norm(self.velocity) < 0.01:
            self.position[0] *= 0.999  # x축 드리프트 보정
            self.position[1] *= 0.999  # y축 드리프트 보정
            # z축은 자연스러운 높이 변화를 위해 덜 보정
            if abs(self.position[2]) < 0.2:  # 작은 높이 변화는 허용
                self.position[2] *= 0.9995
        
        # TF 발행
        self.publish_transform()
        
        # 현재 시간 저장
        self.prev_time = current_time
    
    def quaternion_to_rotation_matrix(self, q):
        """쿼터니언을 회전 행렬로 변환"""
        x, y, z, w = q
        
        # 회전 행렬 계산
        xx = x * x
        xy = x * y
        xz = x * z
        xw = x * w
        
        yy = y * y
        yz = y * z
        yw = y * w
        
        zz = z * z
        zw = z * w
        
        R = np.array([
            [1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw)],
            [2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw)],
            [2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy)]
        ])
        
        return R
    
    def publish_transform(self):
        """TF 변환 발행"""
        t = TransformStamped()
        t.header.stamp = self.get_clock().now().to_msg()
        t.header.frame_id = self.frame_id
        t.child_frame_id = self.child_frame_id
        
        # 위치
        t.transform.translation.x = float(self.position[0])
        t.transform.translation.y = float(self.position[1])
        t.transform.translation.z = float(self.position[2])
        
        # 방향
        t.transform.rotation.x = float(self.orientation[0])
        t.transform.rotation.y = float(self.orientation[1])
        t.transform.rotation.z = float(self.orientation[2])
        t.transform.rotation.w = float(self.orientation[3])
        
        # 발행
        self.tf_broadcaster.sendTransform(t)
    
    def publish_fixed_tf(self):
        """고정된 world -> map 변환 발행"""
        t = TransformStamped()
        t.header.stamp = self.get_clock().now().to_msg()
        t.header.frame_id = 'world'
        t.child_frame_id = 'map'
        
        # 항상 원점에 고정 (약간의 변화는 허용)
        t.transform.translation.x = 0.0
        t.transform.translation.y = 0.0
        t.transform.translation.z = 0.0
        
        # 방향도 고정 (항등 회전)
        t.transform.rotation.x = 0.0
        t.transform.rotation.y = 0.0
        t.transform.rotation.z = 0.0
        t.transform.rotation.w = 1.0
        
        self.tf_broadcaster.sendTransform(t)

def main(args=None):
    rclpy.init(args=args)
    node = ImuTfPublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()