#include "zebedee_lio/submap_manager.hpp"

namespace zebedee_lio
{

SubmapManager::SubmapManager(double sliding_window_size, double voxel_leaf_size) 
: sliding_window_size_(sliding_window_size) 
{
  ikd_tree_ = std::make_shared<KD_TREE<PointType>>(voxel_leaf_size);
}

SubmapManager::~SubmapManager() {}

void SubmapManager::updateSlidingWindow(const Eigen::Vector3d& current_position) 
{
  // 🚨 디버깅을 위해 맵 삭제 로직을 임시로 주석 처리합니다.
  // 🚨 이렇게 하면 맵이 계속 누적되어 Odometry가 정상 작동하는지 확인할 수 있습니다.
  /*
  sliding_window_box_.vertex_min[0] = current_position.x() - sliding_window_size_;
  sliding_window_box_.vertex_min[1] = current_position.y() - sliding_window_size_;
  sliding_window_box_.vertex_min[2] = current_position.z() - sliding_window_size_;
  sliding_window_box_.vertex_max[0] = current_position.x() + sliding_window_size_;
  sliding_window_box_.vertex_max[1] = current_position.y() + sliding_window_size_;
  sliding_window_box_.vertex_max[2] = current_position.z() + sliding_window_size_;

  points_to_delete_.clear();
  
  // Box_Search 함수가 ikd-Tree의 비공개 API일 수 있으므로,
  // 우선은 삭제 로직 전체를 비활성화하여 테스트합니다.
  // ikd_tree_->Box_Search(sliding_window_box_, points_to_delete_);

  // if (!points_to_delete_.empty()) 
  // {
  //   ikd_tree_->Delete_by_range(&sliding_window_box_, Delete_by_range_function::NOT_RECORD, true);
  // }
  */
 (void)current_position; // 사용하지 않는 변수 경고를 피하기 위함
}

void SubmapManager::addPointCloud(const PointCloud::Ptr& cloud_to_add) 
{
  if (cloud_to_add->points.empty()) 
  {
    return;
  }
  ikd_tree_->Build(cloud_to_add->points);
}

PointCloud::Ptr SubmapManager::getSubmap() 
{
  PointCloud::Ptr submap_cloud(new PointCloud());
  // ikd-Tree의 flatten 함수는 root 노드, 저장할 벡터, 저장 타입을 인자로 받습니다.
  ikd_tree_->flatten(ikd_tree_->Root_Node, submap_cloud->points, NOT_RECORD);
  return submap_cloud;
}

KD_TREE<PointType>::Ptr SubmapManager::getTree() 
{
  return ikd_tree_;
}

} // namespace zebedee_lio