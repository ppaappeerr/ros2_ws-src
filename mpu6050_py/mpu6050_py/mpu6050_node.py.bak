import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu
import smbus
import time
import math

class MPU6050(Node):
    def __init__(self):
        super().__init__('mpu6050_node')

        # ROS publisher 생성
        self.pub_imu = self.create_publisher(Imu, 'imu', 10)

        # MPU6050 초기화
        self.bus = smbus.SMBus(1)
        self.device_address = 0x68

        try:
            self.bus.write_byte_data(self.device_address, 0x6B, 0x00)
            self.get_logger().info("MPU6050 Initialized successfully!")
        except Exception as e:
            self.get_logger().error(f"MPU6050 initialization failed: {e}")

        # 50Hz 주기로 publish
        self.timer = self.create_timer(0.02, self.publish_imu_data)

        # self calibration 호출
        self.calibrate()

    def read_raw_data(self, addr):
        try:
            high = self.bus.read_byte_data(self.device_address, addr)
            low = self.bus.read_byte_data(self.device_address, addr + 1)
            value = (high << 8) | low
            if value > 32767:
                value -= 65536
            return value
        except Exception as e:
            self.get_logger().error(f"I2C read error at address {addr:#04x}: {e}")
            raise

    def publish_imu_data(self):
        try:
            acc_x = self.read_raw_data(0x3B) - self.acc_x_offset
            acc_y = self.read_raw_data(0x3D) - self.acc_y_offset
            acc_z = self.read_raw_data(0x3F) - self.acc_z_offset
            gyro_x = self.read_raw_data(0x43) - self.gyro_x_offset
            gyro_y = self.read_raw_data(0x45) - self.gyro_y_offset
            gyro_z = self.read_raw_data(0x47) - self.gyro_z_offset

        except OSError as e:
            self.get_logger().error(f"MPU6050 read failed: {e}")
            return  # skip publishing if error occurs

        # 변환
        Ax = acc_x / 16384.0 * 9.81
        Ay = acc_y / 16384.0 * 9.81
        Az = acc_z / 16384.0 * 9.81
        Gx = math.radians(gyro_x / 131.0)
        Gy = math.radians(gyro_y / 131.0)
        Gz = math.radians(gyro_z / 131.0)

        # 메시지 작성
        imu_msg = Imu()
        imu_msg.header.stamp = self.get_clock().now().to_msg()
        imu_msg.header.frame_id = "base_link"

        imu_msg.linear_acceleration.x = Ax
        imu_msg.linear_acceleration.y = Ay
        imu_msg.linear_acceleration.z = Az

        imu_msg.angular_velocity.x = Gx
        imu_msg.angular_velocity.y = Gy
        imu_msg.angular_velocity.z = Gz

        self.pub_imu.publish(imu_msg)

        # --- MPU6050 클래스 안에 아래 함수 추가 ---
    def calibrate(self):
        self.get_logger().info("Calibrating... Hold still.")
        acc_x_total = 0
        acc_y_total = 0
        acc_z_total = 0
        gyro_x_total = 0
        gyro_y_total = 0
        gyro_z_total = 0
        sample_count = 100

        for _ in range(sample_count):
            acc_x_total += self.read_raw_data(0x3B)
            acc_y_total += self.read_raw_data(0x3D)
            acc_z_total += self.read_raw_data(0x3F)
            gyro_x_total += self.read_raw_data(0x43)
            gyro_y_total += self.read_raw_data(0x45)
            gyro_z_total += self.read_raw_data(0x47)
            time.sleep(0.01)  # 약 100Hz

        self.acc_x_offset = acc_x_total / sample_count
        self.acc_y_offset = acc_y_total / sample_count
        self.acc_z_offset = acc_z_total / sample_count - 16384  # 중력 1g만큼 보정

        self.gyro_x_offset = gyro_x_total / sample_count
        self.gyro_y_offset = gyro_y_total / sample_count
        self.gyro_z_offset = gyro_z_total / sample_count

        self.get_logger().info("Calibration done.")


def main(args=None):
    rclpy.init(args=args)
    node = MPU6050()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()

