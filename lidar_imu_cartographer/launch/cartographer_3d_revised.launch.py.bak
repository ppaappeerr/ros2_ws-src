import os
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, LogInfo, TimerAction
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    pkg_share = get_package_share_directory('lidar_imu_cartographer')
    config_dir = os.path.join(pkg_share, 'config')
    rviz_config = os.path.join(pkg_share, 'rviz', 'cartographer_3d.rviz') # RViz 설정 파일 경로

    use_sim_time = LaunchConfiguration('use_sim_time', default='false')

    # 기본 노드 (센서, Static TF)
    nodes = [
        LogInfo(msg="Cartographer 중심 3D SLAM 시작 (2D LiDAR + IMU)"),
        DeclareLaunchArgument('use_sim_time', default_value='false', description='Use simulation time'),

        # Static TF Publishers
        Node(package='tf2_ros', executable='static_transform_publisher', name='static_tf_base_to_laser',
             arguments=['0', '0', '0', '0', '0', '0', 'base_link', 'laser']),
        Node(package='tf2_ros', executable='static_transform_publisher', name='static_tf_base_to_imu',
             arguments=['0', '0', '-0.0019', '0', '0', '0', 'base_link', 'imu_link']), # Z offset -1.9mm
        # Node(package='tf2_ros', executable='static_transform_publisher', name='static_tf_world_to_map',
        #      arguments=['0', '0', '0', '0', '0', '0', 'world', 'map']), # Optional

        # Sensor Nodes
        Node(package='sllidar_ros2', executable='sllidar_node', name='sllidar_node',
             parameters=[{'frame_id': 'laser', 'serial_port': '/dev/ttyUSB0', 'serial_baudrate': 115200, 'angle_compensate': True}]),
        Node(package='mpu6050_py', executable='mpu6050_node', name='mpu6050_node',
             parameters=[{'frame_id': 'imu_link'}]),
    ]

    # 지연 시작 노드 (Cartographer 및 포인트 클라우드 처리)
    delayed_nodes = [
        # Cartographer Node (Handles map->odom->base_link TF)
        Node(
            package='cartographer_ros',
            executable='cartographer_node',
            name='cartographer_node',
            output='screen',
            parameters=[{'use_sim_time': use_sim_time}],
            arguments=['-configuration_directory', config_dir,
                       '-configuration_basename', 'cartographer_3d_scan_imu.lua'], # Use specific config
            remappings=[
                ('scan', '/scan'), # Use /scan topic directly
                ('imu', '/imu')
            ]
        ),

        # Occupancy Grid Node
        Node(
            package='cartographer_ros',
            executable='cartographer_occupancy_grid_node',
            name='cartographer_occupancy_grid_node',
            output='screen',
            parameters=[{'use_sim_time': use_sim_time, 'resolution': 0.05}],
            remappings=[('map', '/map')] # Default map topic
        ),

        # Optional: PointCloud processing for obstacle detection
        Node(
            package='scan_to_pointcloud',
            executable='scan_to_pointcloud_node', # Make sure executable name is correct
            name='scan_to_pointcloud',
            parameters=[{'input_topic': '/scan', 'output_topic': '/pc_3d', 'output_frame': 'laser'}] # Output in laser frame
        ),
        Node(
            package='scan_to_pointcloud',
            executable='accumulated_pointcloud_node', # Make sure executable name is correct
            name='accumulated_pointcloud',
            parameters=[{
                'input_topic': '/pc_3d',
                'output_topic': '/accumulated_points',
                'target_frame': 'map', # Transform points to map frame
                'use_tf': True,
                'max_points': 100000,
                'grid_size': 0.02,
                'publish_rate': 5.0
            }]
        ),

        # RViz
        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz2',
            arguments=['-d', rviz_config],
            parameters=[{'use_sim_time': use_sim_time}],
            output='screen'
        )
    ]

    # Add delayed nodes with a timer
    nodes.append(TimerAction(period=3.0, actions=delayed_nodes)) # Start after 3 seconds

    return LaunchDescription(nodes)